Virtual memory reduces the load on programmers, especially when the memory program data exceeds main memory size. Also it can be applied to multiprogram easilly so that hardwares of modern processors support virtual memory. But there is no effort to make agreement with specification of hardware mechanism which support virtual memory so that it leads to hardware mechanism imcompatibility. System level programmers cannot help but making decision which leads to bad performance; develop software to fit many different architectures or insert hardware abstraction layer to emulate other hardware interface.
In virtual memory system, main memory stores the portion which is used frequently and the other part is stored on disk which is read when needed. Virtual memory is devided as virtual pages uniformly which is identified by virtual page numbers. Physical memory is also devided as physical page frame which is identified by page frame numbers. Virtual page can be mapped to only unique one physical page frame not multiple page frames. However, page frame can be mapped to muliple virtual pages that is virtual address aliasing so that memory sharing is possible. When space is needed for a new page, then the page which is not used recently paged out from main memory and stored on disk and paged into main memory again when it is needed.  OS allocates physical memory only for virtual memory paged in and the virtual memory is considered mapped if OS has information about its location. 
Mapping informations are recored to page table wich is collected into PTEs(page table entries). Both virtual page number and physical page frame number are not needed in actual implementation, but one of them can be verified from PTE's location in the table.
TLB which is the cache for PTEs make address translation fast. TLB stores virtual page number and physical page frame number can be deduced from it by address space identifier. For load-store operation, TLB should have the PTE mapping with that virtual address. If not, then TLB miss occurs and we should find the PTE for that virtual address and take it into TLB. When there is no mapping in table or the mapped page searched is on disk, page fault occurs. When page fault, OS is interrupted and take page from disk into memory or create new page if there is no page or notice error if that is illegal access. If page exists in memory, corresponding mapping may be in TLB or not. However if a page mapping exists in TLB, the corresponding page must be in physical memory. Page table walking can be simplified by constructing the PTEs contiguously so that virtual page number or physical page frame number can be used as offset to search corresponding PTE. 
Forward mapped or Hierarchical page table indexed by virtual page number
Top-down traversal
First 10bits of virtual address index the 1024 entry root page table whose base physical address is stored in hardware register. The selected PTE gives base physical address of 4KB PTE page which is indexed by next 10 bits of virtual address or indicates that the PTE page is on disk or not allocated yet. The selected PTE gives base physical address(page frame number) of 4KB physical page which is indexed by last 12 bits of virtual address. intel's IA-32 uses this page table walking scheme.
Bottom-top traversal
Top-down method needs memory reference as many as table level. Bottom-top method reduces this overhead and accesses to memory only once for virtual address translation. If it fails uses top-down traversal. First 20 bits of virtual address are used as offset on the 4MB user page table. PTE of the 4MB user page table maps the page with the virtual page number which is same as its index in the user page table. If TLB miss occurs, the PTE is loaded from the user page table to TLB using the virtual address of PTE. If another TLB miss occurs during the load, the system search the corresponding root PTE from the 4KB root page table which is indexed by the first 10 bits of the virtual address. The root page table is accessed using physical address so that another TLB miss cannot occur. MIPS and Alpha use this page table walking scheme
Inverse mapped or Inverted page table indexed by page frame number
The index of PTE of inverted page table is same as page frame number which is it maps so that PTEs are for each page frame, not for each virtual page. Thus page table size is along to physical memory size not vitual memory size. PA-RISC and PowerPC use this scheme.
Shared memory can be implemented by using virtual address aliasing. This allows different process to use same physical memory using different virtual memory with multiple their own PTEs. However, it leads to overhead for managing multiple mapping to same physical memory. Whenever OS changes the location of page, it has to change every PTEs which maps that page.