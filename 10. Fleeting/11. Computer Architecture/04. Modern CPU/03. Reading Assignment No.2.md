Maybe the only way to improve performance of chip is to improve the processor's computational capabilities not to add extra memory or increase the level of systems integration. That is increasing the parallelism on the executing. With superscalars, it can issues multiple insts per cycle nad multithreaded processors can have hardware states for multiple threads(programs). Throughput can be improved by combining multiple independent programs, that is multiprogramming. Also programs can be parallelizable by a compiler or a programmer. It can lead the improvement for throughput ,too.
Both of inst level parallelism and thread level parallelism should be acheived. SMT combines the hardware features of superscalars and multi threaded processors. Then processor can issue multiple insts of multiple threads simultaneously. 
## How SMT works
superscalar has horizontal waste when it cannot find available inst to issue and vertical waste when long latency inst like memory access. In case of multi threaded architecture can resolve the vertical waste by context switching. When there is a thread of long latency inst, it context switch to another thread available to avoid vertical waste. However, it cannot still resolve the horizontal waste with wide issue slots, because only one thread is allowed for each cycle. In comparison, SMT allows multi thread for each cycle, then horizontal waste can be resolved now. Although multi threads with low inst level parallelism fills the issue slots simultaneously. For SMT model, just replicating superscalar resources to cover multi thread is needed and identifier for each thread in BTB and TLB should be added. Only inst fetch unit and processor pipeline should be redesigned for SMT. So that SMT is available to single thread operation, then SMT is also good at programs which cannot be parallelized. 
SMT issues more insts form multi threads so that inst fetch can be bottleneck of SMT. But SMT's fetch unit can fill the issue slots easier by fetching from two threads so that decrease the probability of speculative. 
2.8 fetching
The unit has eight PC to save context of each thread and chooses two thread per cycle and then fetches eight insts from each thread. The thread selection hardware uses Icount feedback which allocates high priority to the threads with the few insts in the decode, renaming and queue pipeline stages. It fills the disptch queue from fast thread to avoid allocating inst with dependency to queue. It maintains the queue with fairly distribution between multiple threads so that increase thread level parallelism. It avoids thread starvation, becuase the threads not choosed has few insts in the pipeline. 
The larger register file has longer access time so extend the register file read and write stage to two cycle to avoid increasing clock period. However, two stage register file access leads to increament of branch miprediction penalty and term between inst fetch and execution. Also the increment time between renaming and commit make the time that insts hold physical register  longer so that the pressure of renaming register file increases. Extra write cycle requires extra data bypassing.
The working set of the multiprogramming workload stress the shared resources such as caches, TLB, branch predictor than single threaded parallel programs. Because of extra two cycle with register file access, SMT should have extra latencies and lower performance when single thread executing, but it is worse very a little that sigle threaded superscalar. Becuase accurate branch prediction and shared renaming registers prevent the extra penalties. In SMT, resource competition interthread can be also problem. It leads to cache misses, TLB misses and branch mispredictions.
SMT has bigger throughput and faster for multi programming workload and parallel workload than single thread superscalar. FGMT speeds up by resolving the vertical waste from superscalar. However just four threads is enough to eliminating the vertical waste and it allows only one thread to issue insts per cycle so that cannot resolve the interthread competition with shared resources. Consequently SMT has better performance than FGMT. Multiprocessors are limited by fixed partition of hardware resources. Within Multiprocessors, Processors become idle with lack of thread level parallelism and cannot achieve high instruction level parallelism due to fixed partition of resources for each processors. The floating point units are a bottleneck of multiprocessors. Although adding the extra resources, other resources become a bottleneck. So it cannot speed up. 