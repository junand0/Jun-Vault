## Basic Concepts
- main memory holds only the most often used portions of a process's address space
	- other portions are stored on disk and retrieved as needed
- OS and hardware support translating virtual address to physical address
	- granularity of pages
- Virtual memory space
	- divided into uniform virtual page identified by VPN
- Physical memory
	- divided into uniform page frames identified by page frame number
- Virtual address aliasing
	- let processor or thread share memory
	- support different views of data with different protections or behaviors
- Demanding page
	- OS page out the lest recently used page to disk to free up space for more active page
	- page in to main memory from disk as the page needed again
	- OS allocates physical memory for the item only when the item is paged in
		- virtual page is considered mapped when the OS has information on its location (in memory or disk)
	- wire down
		- wire down a region of VM $\to$ reserve space for it in physical memory and not allow to be paged out
## PTE
- PTE
	- ID of the page's owner ; address space identifier
		- ASID is unnecessary if every process has its own page table / or if there is another mechanism to distinguish the VAs generated by unrelated processes ; paged segmentation
	- VPN
	- page frame number or location on disk(swap space)
	- a valid bit
	- a reference bit ; whether the page was recently accessed
		- OS periodically clears ref bits of all mapped pages to measure page usage
	- a modify bit
		- page out시 disk에 write back 여부
	- page protection bits
- paged segmentation
	- VAs are translated to PA ; first segment granularity, second page granularity
## TLB
- cache for PTEs
- input
	- VPN / extended by ASID
- output
	- PPN
	- protection info
- TLB miss $\to$ page table walking
- if a page's mapping is in TLB, the page must be in physical memory 
- Page Fault
	- mapped page is in the disk not in memory
	- interrupts OS
		- retrieve page form disk and place it into memory
		- create a new page if page not exist yet
		- send an error to process if the process attempt to access to illegal page
## Page Table
### Hierarchical Page Tables
![400](https://i.imgur.com/zoWzppb.png)
- 32bit address space, byte addressing 
	- = 4GB address space
- 4KB page
	- 4KB per page x $2^{20}$ pages = 4GB address space
- 4 byte per PTE x $2^{20}$ PTEs $\to$ mapping 4GB address space : user page table
	- divide by pages each 4KB $\to$ $2^{10}$ pages
	- 4 byte per PTE x $2^{10}$ PTEs $\to$ 4KB root page table
#### Top-down traversal
![500](https://i.imgur.com/aBuYaEA.png)

#### Bottom up traversal
- top down access requires as many memory references as there are table levels
- bottom up method reduce  this overhead
	- typically accesses only once to translate VA
	- resorts to top down traversal if the initial attempt fails
	- MIPS and ALPHA use this
![500](https://i.imgur.com/45Wmq0z.png)
- VPN top 20bit $\to$ user page table index (VA) $\to$ TLB of user page table miss $\to$ VPN top 10 bit $\to$ root page table index (PA) ; cannot miss $\to$ load root page table PTE to TLB $\to$ retry load user page table PTE to TLB using root page table PTE $\to$ TLB hit
### Inverted page table
![500](https://i.imgur.com/gHxS2oe.png)
- one entry for every page frame in main memory, not one entry for every virtual page
	- index of inverted table PTE = page frame number
	- rarely unused entries wasting space
	- compact size $\to$ good candidate for HW-managed mechanism which need the table to be *wired down* in memory
- system searches page tables to find page frame number  $\to$ page frame number usually unavailable ; index of inverted page table PTE
	- $\to$ use hashed index ; VPN $\to$|hash ftn| hashed index
		- different VPN $\to$|hash ftn| identical hashed index
		- $\to$ collision chain mechanism
- collision chain mechanism
	- collision $\to$ choose a different slot in the table $\to$ adds new entry to the end of chain
	- for short chain length
		- increase range of hash values and size of the hash table
		- inverted page table size change $\to$ cannot get page frame number from index PTE
		- $\to$ must include page frame number in PTE $\to$ large size of hash table
		- To keep small size of hash table, increase the number of memory reference (add hash anchor table)
- Hash anchor table
	- indexed by hash value
	- points to the chain head in the inverted table
	- HAT 2x size $\to$ average collision 1/2

![](https://i.imgur.com/Ppk7vsQ.jpg)
- VA $\to$|hash ftn| HAT(PA) $\to$ inverted table(PA) $\to$ load PTE to TLB ; compare VPN of PTE to VPN of VA $\to$|different| next PTE of chain
## up vs down vs inverted
- top down
	- more than two tiers to cover large addr space & each tier requires memory reference during table walking $\to$ waste time
- bottom up
	- more than two tiers to map a large addr space
	- first tier is searched using VA
		- user PTEs to map user address space are in the cache
		- usually require a single memory reference to cover TLB miss
- OS allocates entire page to space in the table at a time
	- $\to$ waste memory
	- single page in address space require a full PTE page at the level of the user page table
- inverted 
	- No matter how sparsely populated the virtual address does not effect the number of table entires
	- table size = the number of physical pages available in the system
	- Drawbacks
		- only contains entries for virtual pages *actively* occupying physical memory
		- $\to$ extra structure needed for pages on disk $\to$ negate benefit of space saving
		- only one entry for each page frame $\to$ cannot aliasing
	- eliminate hash anchor table
		- POWERPC, PA-RISC
		- reduce minimum memory reference by 1
		- $\to$ increase hash table size $\to$ PTE must contain both VPN and PPN
		- $\to$ can have aliasing
## Shared memory
- Pros
	- reduces physical memory requirements
	- avoid the data copying of message-passing mechanisms when processes communicate
#### Implementation 1 : Virtual address aliasing
- each different VA which maps to same physical page
	- manage each own logical PTEs
		- different proc use different VA for same physical data with different protections
		- different virtual  references to the same physical data to cause different behavior
- Issues
	- increase overhead of managing multiple mappings to the same physical page
		- if OS changes a page location, must update every single PTE mapped to it
		- multiple mappings compete for space in TLB
	- pointers in the shared region
		- linked list in the shared region : each process uses different pointer values to reference data within the region and so each process interprets the pointers in the linked list differently
- Share portions of page tables when data is shared
	- + minimize the duplication of PTEs
	- Ex) duplicate a single PTE of root page table $\to$ share 4MB region
	- + reduce overhead of managing multiple PTEs and impact of multiple PTEs on the TLB
	- - require sharing at large granularities
	- - all mappings to the same physical region should have the same protection
		- can resolve if HW translation mechanism is segmented and supports protection at the segment level
- Unix-based OS
#### Implementation 2 : All processes share a global VA space
- flat address space
	- not divided by ASID per processor
	- single page table
- PA-RISC
## ASID vs Segmentation
- HW assists for providing address space protection
	- address space identifier
	- paged segmentation
### ASID
- MIPS, ALPHA, Sparc
- *OS* places a process's address space identifier in a protected register
- VA concatenated with the ASID $\to$ extended VA produce VA space
#### Sharing memory
- single ASID for each process and single ASID for each page
	- $\to$ circumventing ASID scheme to share memory
- use aliasing
- turning off protection for sharing page
	- should flush the page's mapping from TLB whenever a process runs which should not access the page
## Paged Segmentation
- PowerPC, PA-RISC, x86
- VA $\to$ physical address
	- 1. user addresses are mapped to a global address space at the granularity of segments (> pages)
		- top bits of VA identify the segment
		- bottom bits identify the offset within the segment
	- 2. VAs from the global space are mapped to physical memory at the granularity of pages
- *HW* provide registers for process's segment identifiers
	- OS only can modify
- replace top bit of user address with segment identifier from hardware register
	- replaced top bit of user address is used to determine HW register
#### Sharing memory
-  Segmentation is analogous to having multiple address-space identifiers per process— one for each segment in the user address space.
	- share same segment identifier $\to$ share segment level
	- can sharing between processes safely without making the shared segment visible to other processes
## TLB
- hit $\to$ translate VA to PA without page table walking
- if no mapping in TLB $\to$ HW doesn't access to protection information and it denies the process access to the cache
	- even if the data is in the cache, the process is blocked until TLB is filled
- HW managed TLB
	- HW walks the table
	- no interrupt or interaction with I-cache
	- define page table organization for OS
	- POWERPC, x86
- SW managed TLB
	- interrupt $\to$ TLB-miss handler ; primitive in the OS
	- - slow than HW if there is no TLB miss exception inst in the I-cache
	- - can be occur flush $\to$ remove many insts in ROB
	- + allow OS to choose any page table organization : flexible
	- MIPS, Sparc, Alpha, PA-RISC
### Sharing memory
- no need flush with context switching with address space protection mechanism
	- flush is only needed when OS reassigns ASID or segment identifier to a new process or when fewer ASID than currently active processes
- Most inst set provide an inst to invalidate *a single TLB entry with a specific VPN and ASID* but most don't provide an inst to invalidate *all TLB entries matching an ASID*
	- OS invalidate the entire TLB or *individually* invalidate each entry that matches the ASID
	- It is cheaper to invalidate all TLB
## MIPS
- OS handles TLB misses entirely in SW
	- OS walks page table, fills the TLB with any TLB replacement policy
- HW supports a bottom up hierarchical page table through context register
	- TLB context register :
		- holds a VA partitioned into a SW-loaded segment and a HW-loaded segment
	- SW-loaded segment :
		- top most bits of user VA and base VA of a user page table
	- HW-loaded segment : 
		- bottom most bits of user VA and holds the VPN of faulting address
		- filled whenever a user level reference misses TLB
		- indexes a single PTE within the linear user page table
- On TLB miss
	- context register contains a VA for that PTE which maps the faulting address
	- TLB miss handler loads using VA of context register
- use ASID
	- periodic flush cache and TLB due to only 64 unique context identifiers (< active processes)
![500](https://i.imgur.com/QsogiaN.png)
>Hybrid : virtually indexed , physically tagged

## POWERPC
- mapping effective address to a global flat virtual address space
	- 256MB contiguous Segments $\to$ 16 segments = 4GB address space
- effective address
	- top 4 bit = segment identifier $\to$ select(index) segment register (24 bits)
- segment register
	- no explicit ASID
	- only modified by OS
	- 24 bits $\to$ can identify over a million processes (rarely remap)
- hashed page table of OS
	- act as eight-way set-associative software cache for PTEs
	- need backup page table for pages on disk
	- TLB miss $\to$ hashed page table walking by HW $\to$ SW inserts PTEs to TLB
![400](https://i.imgur.com/vnt283F.png)

## x86
- Pentium Pro
- segmented Architecture with no explicit ASID
- per process hierarchical page tables
	- HW defined, HW walked
		- walk 2 tier table in top-down using CR3 on TLB miss
	- OS provides to HW PA for the root page table in control register CR3
	- each process has its own page table : 
		- context switching $\to$ TLB flush & CR3 change $\to$ TLB에 current process의 page table에 속하는 PTE만 들어있도록 보장
- segmentation
	- mapping user level address to global linear address space (4GB)
	- variable sized segments from 1 byte to 4GB
	- HW uses 16 bit segment selector (top most bits of user address) $\to$ index one of two SW descriptor tables $\to$ producing a base address for the segment corresponding to the selector $\to$ base address + 32 bit VA = 32 bit global linear address
- segment selector
	- HW가 process의 selector 중 6개를 on-chip segment register에 caching하고 이는 context에 따라 reference됨
	- 1개는 inst 실행에 의해 reference되고 해당되는 segment에 code가 저장됨
	- 1개는 stack을 mapping
	- 나머지 4개는 data segment mapping
	- programmer can specify which of the segment registers to reference for different loads and stores

![400](https://i.imgur.com/UPVOE4o.png)
